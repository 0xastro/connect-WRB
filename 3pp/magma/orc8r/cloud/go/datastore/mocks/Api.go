/*
Copyright (c) Facebook, Inc. and its affiliates.
All rights reserved.

This source code is licensed under the BSD-style license found in the
LICENSE file in the root directory of this source tree.
*/

// To regenerate this when the interface changes, run
// mockery -name=Api in datastore/

// Code generated by mockery v1.0.0
package mocks

import (
	"magma/orc8r/cloud/go/datastore"

	"github.com/stretchr/testify/mock"
)

// Api is an autogenerated mock type for the Api type
type Api struct {
	mock.Mock
}

// Delete provides a mock function with given fields: table, key
func (_m *Api) Delete(table string, key string) error {
	ret := _m.Called(table, key)

	var r0 error
	if rf, ok := ret.Get(0).(func(string, string) error); ok {
		r0 = rf(table, key)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// DeleteMany provides a mock function with given fields: table, keys
func (_m *Api) DeleteMany(table string, keys []string) (map[string]error, error) {
	ret := _m.Called(table, keys)

	var r0 map[string]error
	if rf, ok := ret.Get(0).(func(string, []string) map[string]error); ok {
		r0 = rf(table, keys)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(map[string]error)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(string, []string) error); ok {
		r1 = rf(table, keys)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// DeleteTable provides a mock function with given fields: table
func (_m *Api) DeleteTable(table string) error {
	ret := _m.Called(table)

	var r0 error
	if rf, ok := ret.Get(0).(func(string) error); ok {
		r0 = rf(table)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// DoesKeyExist provides a mock function with given fields: table, key
func (_m *Api) DoesKeyExist(table string, key string) (bool, error) {
	ret := _m.Called(table, key)

	var r0 bool
	if rf, ok := ret.Get(0).(func(string, string) bool); ok {
		r0 = rf(table, key)
	} else {
		r0 = ret.Get(0).(bool)
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(string, string) error); ok {
		r1 = rf(table, key)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Get provides a mock function with given fields: table, key
func (_m *Api) Get(table string, key string) ([]byte, uint64, error) {
	ret := _m.Called(table, key)

	var r0 []byte
	if rf, ok := ret.Get(0).(func(string, string) []byte); ok {
		r0 = rf(table, key)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]byte)
		}
	}

	var r1 uint64
	if rf, ok := ret.Get(1).(func(string, string) uint64); ok {
		r1 = rf(table, key)
	} else {
		r1 = ret.Get(1).(uint64)
	}

	var r2 error
	if rf, ok := ret.Get(2).(func(string, string) error); ok {
		r2 = rf(table, key)
	} else {
		r2 = ret.Error(2)
	}

	return r0, r1, r2
}

// GetMany provides a mock function with given fields: table, keys
func (_m *Api) GetMany(table string, keys []string) (map[string]datastore.ValueWrapper, error) {
	ret := _m.Called(table, keys)

	var r0 map[string]datastore.ValueWrapper
	if rf, ok := ret.Get(0).(func(string, []string) map[string]datastore.ValueWrapper); ok {
		r0 = rf(table, keys)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(map[string]datastore.ValueWrapper)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(string, []string) error); ok {
		r1 = rf(table, keys)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// ListKeys provides a mock function with given fields: table
func (_m *Api) ListKeys(table string) ([]string, error) {
	ret := _m.Called(table)

	var r0 []string
	if rf, ok := ret.Get(0).(func(string) []string); ok {
		r0 = rf(table)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).([]string)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(string) error); ok {
		r1 = rf(table)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}

// Put provides a mock function with given fields: table, key, value
func (_m *Api) Put(table string, key string, value []byte) error {
	ret := _m.Called(table, key, value)

	var r0 error
	if rf, ok := ret.Get(0).(func(string, string, []byte) error); ok {
		r0 = rf(table, key, value)
	} else {
		r0 = ret.Error(0)
	}

	return r0
}

// PutMany provides a mock function with given fields: table, valuesToPut
func (_m *Api) PutMany(table string, valuesToPut map[string][]byte) (map[string]error, error) {
	ret := _m.Called(table, valuesToPut)

	var r0 map[string]error
	if rf, ok := ret.Get(0).(func(string, map[string][]byte) map[string]error); ok {
		r0 = rf(table, valuesToPut)
	} else {
		if ret.Get(0) != nil {
			r0 = ret.Get(0).(map[string]error)
		}
	}

	var r1 error
	if rf, ok := ret.Get(1).(func(string, map[string][]byte) error); ok {
		r1 = rf(table, valuesToPut)
	} else {
		r1 = ret.Error(1)
	}

	return r0, r1
}
