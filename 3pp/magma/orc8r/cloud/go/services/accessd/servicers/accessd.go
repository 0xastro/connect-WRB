/*
Copyright (c) Facebook, Inc. and its affiliates.
All rights reserved.

This source code is licensed under the BSD-style license found in the
LICENSE file in the root directory of this source tree.
*/

/*
Accessd service provides the gRPC interface for cloud services & REST server to
check & manage Identity access permissions.
*/
package servicers

import (
	"golang.org/x/net/context"
	"google.golang.org/grpc/codes"
	"google.golang.org/grpc/status"

	"magma/orc8r/cloud/go/datastore"
	"magma/orc8r/cloud/go/protos"
	accessprotos "magma/orc8r/cloud/go/services/accessd/protos"
)

const (
	ACCESS_TABLE = "access_control"
)

type AccessControlServer struct {
	store datastore.Api
}

func NewAccessdServer(store datastore.Api) *AccessControlServer {
	return &AccessControlServer{store}
}

// SetOperator Overwrites Permissions for operator Identity to manage others
// Request includes ACL to add for the Operator
func (srv *AccessControlServer) SetOperator(ctx context.Context, req *accessprotos.AccessControl_ListRequest) (*protos.Void, error) {

	err := verifyACLRequest(req)
	if err != nil {
		return &protos.Void{}, err
	}

	acl := &accessprotos.AccessControl_List{Operator: req.Operator,
		Entities: map[string]*accessprotos.AccessControl_Entity{}}
	err = addToACL(req.Operator, acl, req.Entities)
	if err != nil {
		return &protos.Void{}, err
	}

	return &protos.Void{}, srv.putACL(req.Operator, acl)
}

// AddACL Adds Permissions for one Identity to manage others
// Request includes ACL to add for the Operator
func (srv *AccessControlServer) UpdateOperator(ctx context.Context, req *accessprotos.AccessControl_ListRequest) (*protos.Void, error) {

	voidVar, err := &protos.Void{}, verifyACLRequest(req)
	if err != nil {
		return voidVar, err
	}

	acl, err := srv.getACL(req.Operator)
	if err != nil {
		return voidVar, err
	}

	err = addToACL(req.Operator, acl, req.Entities)
	if err != nil {
		return voidVar, err
	}

	err = srv.putACL(req.Operator, acl)
	if err != nil {
		return voidVar, err
	}

	return voidVar, nil
}

// DeleteOperator Removes all operator's permissions (the entire operator's ACL)
func (srv *AccessControlServer) DeleteOperator(ctx context.Context, oper *protos.Identity) (*protos.Void, error) {

	if oper == nil {
		return &protos.Void{}, status.Errorf(codes.InvalidArgument, "Nil Operator")
	}
	opkey, table := getKeyTablePair(oper)
	err := srv.store.Delete(table, opkey)
	if err != nil {
		return &protos.Void{}, status.Errorf(codes.NotFound, "Operator %s Delete from table %s error: %s", opkey, table, err)
	}
	return &protos.Void{}, nil
}

// GetOperatorACL Returns the managing Identity's permissions list
func (srv *AccessControlServer) GetOperatorACL(ctx context.Context, oper *protos.Identity) (*accessprotos.AccessControl_List, error) {
	return srv.getACL(oper)
}

// GetOperatorsACLs Returns the managing Identities' permissions list
func (srv *AccessControlServer) GetOperatorsACLs(
	ctx context.Context, opers *protos.Identity_List,
) (*accessprotos.AccessControl_Lists, error) {
	res, err := srv.getACLs(opers.GetList())
	return &accessprotos.AccessControl_Lists{Acls: res}, err
}

// Returns the managing Identity's permissions for a given entity
// NOTE: Takes into account wildcards for the entity's type in the ACL
func (srv *AccessControlServer) GetPermissions(
	ctx context.Context,
	req *accessprotos.AccessControl_PermissionsRequest,
) (*accessprotos.AccessControl_Entity, error) {
	return srv.getACLEntity(req)
}

// Returns the managing Identity's permissions for a given entity
// NOTE: Takes into account wildcards for the entity's type in the ACL
func (srv *AccessControlServer) CheckPermissions(
	ctx context.Context,
	req *accessprotos.AccessControl_ListRequest,
) (*protos.Void, error) {

	voidRes := &protos.Void{}
	err := verifyACLRequest(req)
	if err != nil {
		return voidRes, err
	}
	acl, err := srv.getACL(req.Operator)
	if err != nil {
		return voidRes, err
	}
	return voidRes, checkEntitiesPermissions(acl, req.Entities)
}

// Lists all globally registered operators on the cloud
func (srv *AccessControlServer) ListOperators(ctx context.Context, _ *protos.Void) (*protos.Identity_List, error) {
	res := new(protos.Identity_List)
	keys, err := srv.store.ListKeys(ACCESS_TABLE)
	if err != nil {
		return res, status.Errorf(codes.NotFound, "Error %s listing table %s keys", err, ACCESS_TABLE)
	}
	operators := make([]*protos.Identity, len(keys))
	for i, key := range keys {
		acl, err := srv.getACLForKey(ACCESS_TABLE, key)
		if err != nil {
			return res, err
		}
		operators[i] = acl.Operator
	}
	res.List = operators
	return res, nil
}

// Cleanup a given entity from all Operators' ACLs
// TBD: This needs to be implemented to avoid security venerability when deleting
//      a network with customer selected ID (vs. generated by the cloud ID)
func (srv *AccessControlServer) DeleteEntity(ctx context.Context, ent *protos.Identity) (*protos.Void, error) {
	return &protos.Void{}, status.Errorf(codes.Unimplemented, "Not Implemented")
}
